

const fs = require('fs');
const path = require('path');
const os = require('os');
const crypto = require('crypto');
const packageJson = require('../package.json');

const version = packageJson.version;


function createError(message, code) {
  const err = new Error(message);
  err.code = code;
  return err;
}

function _warn(message) {
  console.warn(`[dotenv@${version}][WARN] ${message}`);
}

function _debug(message) {
  console.debug(`[dotenv@${version}][DEBUG] ${message}`);
}

function _resolveHome(envPath) {
  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath;
}

function _dotenvKey(options) {
  return (options?.DOTENV_KEY || process.env.DOTENV_KEY || '').trim();
}

const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;

function parse(src) {
  if (!src || (typeof src !== 'string' && !Buffer.isBuffer(src))) {
    throw createError('INVALID_SOURCE: Expected a string or buffer to parse', 'INVALID_SOURCE');
  }

  const obj = {};
  const lines = src.toString().replace(/\r\n?/mg, '\n');

  let match;
  while ((match = LINE.exec(lines)) !== null) {
    const key = match[1];
    let value = (match[2] || '').trim();
    const maybeQuote = value[0];
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2');

    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, '\n').replace(/\\r/g, '\r');
    }

    obj[key] = value;
  }

  return obj;
}

function _vaultPath(options) {
  let possibleVaultPath = options?.path;

  if (Array.isArray(possibleVaultPath)) {
    for (const filepath of possibleVaultPath) {
      const fullPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`;
      if (fs.existsSync(fullPath)) return fullPath;
    }
  } else if (possibleVaultPath) {
    const fullPath = possibleVaultPath.endsWith('.vault') ? possibleVaultPath : `${possibleVaultPath}.vault`;
    if (fs.existsSync(fullPath)) return fullPath;
  }

  const defaultPath = path.resolve(process.cwd(), '.env.vault');
  return fs.existsSync(defaultPath) ? defaultPath : null;
}

function _instructions(result, dotenvKey) {
  let uri;
  try {
    uri = new URL(dotenvKey);
  } catch (err) {
    throw createError('INVALID_DOTENV_KEY: Must be a valid URI', 'INVALID_DOTENV_KEY');
  }

  const key = uri.password;
  const env = uri.searchParams.get('environment');
  const environmentKey = `DOTENV_VAULT_${env?.toUpperCase()}`;

  if (!key || !env || !result.parsed[environmentKey]) {
    throw createError(`INVALID_DOTENV_KEY: Missing key or environment info`, 'INVALID_DOTENV_KEY');
  }

  return { ciphertext: result.parsed[environmentKey], key };
}

function decrypt(encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), 'hex');
  let ciphertext = Buffer.from(encrypted, 'base64');
  const nonce = ciphertext.subarray(0, 12);
  const authTag = ciphertext.subarray(-16);
  ciphertext = ciphertext.subarray(12, -16);

  try {
    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce);
    aesgcm.setAuthTag(authTag);
    return aesgcm.update(ciphertext) + aesgcm.final();
  } catch (error) {
    if (error instanceof RangeError || error.message === 'Invalid key length') {
      throw createError('INVALID_DOTENV_KEY: Must be 64 hex chars', 'INVALID_DOTENV_KEY');
    } else if (error.message === 'Unsupported state or unable to authenticate data') {
      throw createError('DECRYPTION_FAILED: Check your DOTENV_KEY', 'DECRYPTION_FAILED');
    }
    throw error;
  }
}

function _parseVault(options) {
  const vaultPath = _vaultPath(options);
  if (!vaultPath) {
    throw createError('VAULT_FILE_NOT_FOUND: .env.vault not found', 'VAULT_FILE_NOT_FOUND');
  }

  const result = DotenvModule.configDotenv({ path: vaultPath });
  if (!result.parsed) {
    throw createError('MISSING_DATA: Could not parse .env.vault', 'MISSING_DATA');
  }

  const keys = _dotenvKey(options).split(',');
  for (const key of keys) {
    try {
      const attrs = _instructions(result, key.trim());
      const decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
      return DotenvModule.parse(decrypted);
    } catch (err) {
      continue; 
    }
  }

  throw createError('DECRYPTION_FAILED: All keys failed', 'DECRYPTION_FAILED');
}

function populate(processEnv, parsed, options = {}) {
  const override = Boolean(options.override);
  const debug = Boolean(options.debug);

  if (typeof parsed !== 'object') {
    throw createError('OBJECT_REQUIRED: parsed must be an object', 'OBJECT_REQUIRED');
  }

  for (const key in parsed) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override) processEnv[key] = parsed[key];
      if (debug) _debug(`"${key}" already exists and ${override ? 'was' : 'was NOT'} overwritten`);
    } else {
      processEnv[key] = parsed[key];
    }
  }
}

function configDotenv(options = {}) {
  try {
    const paths = Array.isArray(options.path)
      ? options.path.map(_resolveHome)
      : [_resolveHome(options.path || '.env')];

    const parsedAll = {};
    let lastError;

    for (const filePath of paths) {
      try {
        const content = fs.readFileSync(filePath, { encoding: options.encoding || 'utf8' });
        const parsed = DotenvModule.parse(content);
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        lastError = e;
        if (options.debug) _debug(`Failed to read ${filePath}: ${e.message}`);
      }
    }

    if (Object.keys(parsedAll).length === 0 && lastError) {
      throw lastError;
    }

    DotenvModule.populate(options.processEnv ?? process.env, parsedAll, options);
    return { parsed: parsedAll };

  } catch (err) {
    throw createError(`CONFIG_DOTENV_ERROR: ${err.message}`, 'CONFIG_DOTENV_ERROR');
  }
}

function _configVault(options = {}) {
  if (options.debug) _debug('Using encrypted .env.vault');
  const parsed = DotenvModule._parseVault(options);
  DotenvModule.populate(options.processEnv ?? process.env, parsed, options);
  return { parsed };
}

function config(options = {}) {
  try {
    if (!_dotenvKey(options)) {
      return DotenvModule.configDotenv(options);
    }

    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn('DOTENV_KEY is set but .env.vault is missing');
      return DotenvModule.configDotenv(options);
    }

    return DotenvModule._configVault(options);
  } catch (error) {
    throw createError(`CONFIG_ERROR: ${error.message}`, 'CONFIG_ERROR');
  }
}

const DotenvModule = {
  parse,
  decrypt,
  populate,
  config,
  configDotenv,
  _configVault,
  _parseVault
};

module.exports = DotenvModule;
